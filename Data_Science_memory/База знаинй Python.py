//////////////////
///ТИПЫ ДАННЫХ///
////////////////
a = 5 		#int
a = 5.0 	#float
a = "5"		#string
a = True 	#bool print(True+False+False+True) = 2  print(True+False+False+True) = 0 print(True+True+True+True) = 1
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////








/////////////
///СТРОКИ///
///////////
#Задание строк. Нумерация начинается с 0!!! "01234..."
str1 = 'Hello!'
str2 = "Hello!"
str3 = '''Hello,
				world'''

/Метод .len()
#Длина строки
str1 = "Hello!"
str1.len() 
# 6

/Метод .upper()
#Все буквы большие
str1 = "Hello!"
str1.upper() 
# "HELLO!"

/Метод .lower()
#Все буквы маленькие
str1 = "Hello!"
str1.lower() 
# "hello!"

/Метод .title() #.capitalize() - первая большая, а все остальные маленькие
#Первая буква большая, остальные маленькие
str1 = "Hello!"
str1.title() 
# "Hello!"

/Метод .swapcase()
#Меняет регистр символов
str1 = "Hello!"
str1.swapcase() 
# "hELLO!"

/Метод .find()
#Возвращает индекс первого встреченного заданного символа
str1 = "Hello!"
str1.find() 
# 2

/Метод .rfind()
#Возвращает индекс последнего встреченного заданного символа
str1 = "Hello!"
str1.rfind() 
# 3

/Метод .isdigit()
#Возвращает True, если строка только из цифр

/Метод .isalpha()
#Возвращает True, если строка только из букв

/Метод .isalnum()
#Возвращает True, если строка только из цифр и букв, но не содержит символы

/Метод .replace("что меняем","на что меняем")
#Заменяет символы или удаляет, если заменить на ''
s = "Hello$ Python3$" 
s1 = s.replace("$", "") 
print (s1) 
# Результат: Hello Python3

/Метод .split() #Здесь разделение идет по пробелу, но можно и по другим символам .split("символ")
#Разделяет текст по словам, от пробела до пробела
colors = 'red blue green'
print(colors.split())
# ['red', 'blue', 'green']
#Результат работы этого метода — список строк.

/Метод 'чем склеить'.join(список)
#Соединяет элементы списка нужным символом
colors = 'red green blue'
colors_split = colors.split() # список цветов по отдельности
colors_joined = ' and '.join(colors_split) # объединение строк
print(colors_joined)
# red and green and blue
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////








///////////////
///f-СТРОКИ///
/////////////
#Возможно создание форматированных строк

/Метод .format()
print("The {} currancy rate on the date {} is {}".format(currancy, cur_date, rate))

/f-строки
print(f"The {currancy} currancy rate on the date {cur_date} is {rate*1.2:.3f}") #Также можно производить операции с переменными
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////








///////////
///ВВОД///
/////////
a = input()    
#или 
a = input("Здесь можно писать о том, что нужно ввести: ")
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////







	
////////////
///ВЫВОД///
//////////
print("Здесь можно писать о том, что нужно вывести:", a, sep='',end='\n')

sep='' #аргумент, отвечающий за то, как будут разделяться выводимые данные
print('a','b',sep='')
print('a','b',sep=' ')
print('a','b',sep=',')
print('a','b',sep='123')
#ab
#a b
#a,b
#a123b

end='' #аргумент задаёт символ, которым заканчивается печатаемая строка (по умолчанию это перенос на новую строку — символ \n).
print('a','b',end='\n')
print('a','b',end=', ')
print('a','b',end='\n\n')
print('a','b',end='!!!')
#a b
#a b, a b
#
#a b!!!
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////








/////////////
///СПИСКИ///
///////////
#Список в Python — это упорядоченная ИЗМЕНЯЕМАЯ коллекция объектов произвольных типов
#Важно: в списке можно хранить не только простые типы (числа, строки), но также кортежи, 
#словари, списки, списки внутри списков и даже функции.

#2 варианта создания списков:
my_list = list()
my_list = [ ]
			
a = 3
spisok = [1,2,a,'a',"Text luboy",[1,'abc',3],(5,8,9)]
#[1, 2, 3, 'a', "Text luboy",[1,'abc',3],(5,8,9)]

/Индексация
#spisok[0] = [1]
#spisok[1] = [2]
#spisok[-1] = ["Text luboy"]

/Срезы
#spisok[1:3] = [2, 3, 'a'] 
#spisok[0:4:2] = [1, 3, "Text luboy"] - взятие только четных индексов

//Генератор целочисленных списков определённой длины
a = range(начало, конец, шаг) - конец не входит в список
a = range(0, 10, 2)
[0, 2, 4, 6, 8]

шаг может быть отрицательным
a = range(10, 3, -1)
[10, 9, 8, 7, 6, 5, 4]

/Метод .append()
#Добавляем элемент в конец списка
orders_daily = [] 
# изначально список с чеками пустой
orders_daily.append("order1")
orders_daily 
# [“order1”] — в списке появился первый чек.

/Метод .clear()
#Очистка списка
a = ["order1", "order2", "order3", "order4"]
a.clear()
a 
# []

#синтаксический сахар
a = []
a 
# []

/Метод .count()
#Число элементов в списке
a = ["a", "b", "c", "d", "b", "b", "g", "b", "r"]
a.count("b") 
# 4

/Метод .copy()
#Копирование списка
a = [1,2,3]
b = a.copy()
b 
# [1,2,3]

#В Python есть синтаксический сахар для данного метода — две квадратные скобки с двоеточием внутри [:]. 
#Мы как бы говорим: «Сделай мне полный срез исходного списка в другую переменную»:
a = [1,2,3]
b = a[:]
b 
# [1,2,3]

/Метод .extend()
#Приклеивание списка
a = ["a", "b", "c"]
b = ["d", "e"]
a.extend(b)
a 
# ["a", "b", "c", "d", "e"]

/Метод .reverse()
#Переворот списка начало-конец
a = [1,2,3,4,5]
a.reverse()
a 
# [5,4,3,2,1]

#синтаксический сахар
a = [1,2,3,4,5]
b = a[::-1]
b 
# [5,4,3,2,1]

/Метод .sort()
#Сортировка от 0 до бесконечности, от a до z (от 1 буквы (сначала поставит cab, а потом cav)), сначала заглавные, потом прописные
a = [3,4,1,5,10,0, 2]
a.sort()
a 
# [0, 1, 2, 3, 4, 5, 10]

/Сгладить список списков с помощью sum
#Суммирование по внутренним спискам-это еще одно решение. Функция имеет два параметра: iterable , 
#который является списком списков, и start , который является пустым списком в нашем случае, 
#который служит исходным плоским списком, к которому добавляются элементы внутренних подсписков.

#Этот подход удобен тем, что вам не нужно ничего импортировать, но он медленнее, чем функции 
#itertools() и chain() при большом количестве подсписков:

regular_list = [[1, 2, 3, 4], [5, 6, 7], [8, 9]]

flat_list = sum(regular_list, [])

print('Original list', regular_list)
print('Transformed list', flat_list)

regular_list = [[1, 2, 3, 4], [5, 6, 7], [8, 9]]
​
flat_list = sum(regular_list, [])
​
print('Original list', regular_list)
print('Transformed list', flat_list)
​


/



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////








/////////////
///КОРТЕЖ///
///////////
#Кортежи в Python — это упорядоченная НЕИЗМЕНЯЕМАЯ коллекция объектов произвольных типов
#Важно: в кортеже можно хранить не только простые типы (числа, строки), но также кортежи, 
#словари, списки, списки внутри списков и даже функции.
#Кортежи занимают меньше места, чем списки

#2 варианта создания кортежей:
tpl1 = tuple()
tpl1 = ()

tpl3 = ("s") - переменная типа string
# "s"
tpl4 = ("s", ) - кортеж
# ("s", )
			
a = 3
kortez = (1,2,a,'a',"Text luboy",[1,'abc',3],(5,8,9))
#(1, 2, 3, 'a', 'Text luboy',[1,'abc',3],(5,8,9))
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////








//////////////
///СЛОВАРЬ///
////////////
#Хранит в себе ключи и значения

#2 варианта создания словарей:
my_dict = dict() 
my_dict = {} 

//Образец словаря
phones = {'+79033923029': 'Ivan Ivanov', '+78125849204': 'Kirill Smirnov', '+79053049385': 'Mark Parkhomenko', '+79265748370': 'Ekaterina Dmitrieva', '+79030598495': 'Ruslan Belyi'}

/Обращение по ключу
phones["+79265748370"] 
# Ekaterina Dmitrieva

/Обновление элементов
phones["+79265748370"]  = 'Ekaterina Ershova'
phones["+79265748370"] 
#  Ekaterina Ershova

/Добавление элементов
phones["+79686581788"]  = 'Artem Pliev'

/Метод .clear()
#Очистка словаря
phones.clear()
phones 
# {}

#синтаксический сахар
phones = {}
# {}

/Метод .keys()
#Возвращает ключи словаря
phones.keys() 
# dict_keys(['+79033923029', '+78125849204', '+79053049385', '+79265748370', '+79030598495', '+79686581788'}

/Метод .values()
#Возвращает значения словаря без привязки к ключам
phones.values()
# dict_values(['Ivan Ivanov', 'Kirill Smirnov', 'Mark Parkhomenko', 'Ekaterina Dmitrieva', 'Ruslan Belyi', 'Artem Pliev'}

/Метод .get()
#Выводит значени по ключу, но если не найдет, то не выдает ошибку, как при обычном обращении
phones.get("+79265748370", "I don't have it!") 
# Ekaterina Dmitrieva
#А если не найдет, то выведет все, что в аргументе, хоть число! (Здесь "I don't have it!")

/Метод .update()
#Добавляет или обновляет элементы не по одному, как через {}, а можно сразу несколько
phones.update({"+79686581788":'Artem Pliev'})

/Метод .pop()
#Удаляет элмент, но с присвоением удаленного элемента преременной, используя ключ
phones2 = phones.pop("+79686581788")
#'Artem Pliev'

/Метод .setdefault()
#Если не было элемента, то создаст, если был, то оставит не изменным
phones.setdefault('+79033923029', 'Ivan Petrov')
phones = {'+79033923029': 'Ivan Ivanov', '+78125849204': 'Kirill Smirnov', '+79053049385': 'Mark Parkhomenko', '+79265748370': 'Ekaterina Dmitrieva', '+79030598495': 'Ruslan Belyi'}
phones['+79033923029']
#'Ivan Ivanov'

/Метод .items()
#






/////////////////////////////////////////////////////////////////////////////////////////////////////////////////








///////////////
///МНОЖЕСТВА///
///////////////
#Множество — это структура данных. Типы элементов внутри множества могут быть различными. Порядок элементов не фиксирован.

#С множествами можно делать многие операции из теории множеств: объединение, пересечение, вычитание и т. д. 
#Можно проверять принадлежность элемента к множеству.

#Любые неизменяемые типы данных могут быть элементами множества: числа, строки, кортежи.

#→ В отличие от списков, где элементы хранятся в виде последовательностей, в множествах порядок хранения элементов не определён. 
#Внутри множества представлены с помощью «хитрых» алгоритмов, которые позволяют выполнять операции типа 
#«проверить принадлежность элемента множеству» быстрее, чем просто перебором всех элементов множества.

#2 варианта создания множеств:
set1 = set()
set1 = {'chto-nubed'} - множество. Нужно указать хотя бы один элемент
!!!
set1 = {} - словарь

//Образец множества
s1 = set("hello")
#  {‘h’, ‘l’, ‘e’, ‘o’} - мы имеем одну l, так как в множествах нет повторений. Не важно число раз,
#встреч компонентов, варно просто наличие.

/Метод .add()
#быстро и безболезненно добавляет 1 элемент в множество 
s = {1, 2, 3, 4}
s.add(5)
# {1, 2, 3, 4, 5}

/Метод .update()
#Добавляет во множество сразу несколько элементов. Ему можно передать один или сразу несколько итерируемых 
#объектов (строк, списков, кортежей, множеств), если, их там ещё нет.
#Если нужно добавить числа, то нужно оформлять их как текст
s = {1, 2, 3, 4}
s.update('578')
# {1, 2, 3, 4, 5, 7, 8}

/Методы .remove() и .discard()
#Удаляют указанные объекты
#Если элемента нет, то первый выдаст ошибку, а второй проигнорирует.
#Применение зависит от логики работы программы
s1 = {1,2,3,4,5}
s1.remove(10)
# Ошибка KeyError: 10
s1.discard(10)
# Ничего не произошло

/Опрерация над множествами .union()
#Объединение множеств
cluster1 = {"item1", "item2", "item3", "item4"}
cluster2 = {"item2", "item3", "item5", "item7"}
cluster1.union(cluster2) 
# {"item1", "item2", "item3", "item4", "item5", "item7"}

/Опрерация над множествами .intersection()
#Пересечение множеств
cluster1 = {"item1", "item2", "item3", "item4"}
cluster2 = {"item2", "item3", "item5", "item7"}
cluster1.intersection(cluster2) 
# {"item2", "item3"}

/Опрерация над множествами .difference()
#Вычитание множеств
cluster1 = {"item1", "item2", "item3", "item4"}
cluster2 = {"item2", "item3", "item5", "item7"}
cluster1.intersection(cluster2) 
# {"item1", "item4"}

/Опрерация над множествами .issubset()
#Сравнение множеств
cluster1 = {"item1", "item2", "item3", "item4"}
cluster2 = {"item2", "item3", "item5", "item7"}
cluster1.intersection(cluster2) 
# False


///ИЗМЕНЕНИЕ(ПРИВЕДЕНИЕ) ТИПОВ ДАННЫХ///
#to float - происходит автоматически. Писать не обязательно, но нужно знать.
var_float = float(var)

#to int - обрубает дробную часть, а не округляет!!! int(7.8) = 7!!!
var_int = int(var)

#str
var_str = str(var)

#to кортеж
vat_tuple = tuple()

#to список
var_list = list()
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////








//////////////////////////
///ОПЕРАТОРЫ СРАВНЕНИЯ///
////////////////////////
a == b
a != b
a > b
a < b
a <= b
a >= b
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////







///////////////////////////
///ЛОГИЧЕСКИЕ ОПЕРАТОРЫ///
/////////////////////////
#Логическое «НЕ»				Возвращает противоположное значение
not	

#Логическое «ИЛИ»				Возвращает True, если хотя бы одна из переменных True
or

#Логическое «И»					Возвращает True, если обе переменные True
and	

#Проверка принадлежности		Возвращает True, если проверяемая переменная содержится/не содержится в 
#								последовательности (списке, кортеже, строке...)
in 
not in	
print('5' in str(123456789))
#	True

#Проверка тождественности		Возвращает True, если проверяемые объекты эквивалентны/не эквиваленты. 
#								То есть переменные ссылаются на один и тот же адрес в памяти компьютера
is 
is not	
a = [1, 2, 3]
print(id(a))  # id возвращает идентификатор объекта
# 140039772293512

b = a
print(id(b))
# 140039772293512

print(a is b)  # а и b являются одним и тем же объектом
# True
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////







////////////////////////
///УСЛОВНЫЙ ОПЕРАТОР///
//////////////////////
if Условие:
    Блок инструкций 1
elif Условие N:
	Блок инструкций N
else:
    Блок инструкций 2

//Пример
if a == 10:
    print('a equals 10') # a равно 10
elif a < 10:
    print('a is less than 10') # a меньше 10
else:
    print('a is more than 10') # a больше 10

//Инлайновый - if
a = 42
b = 41
if a > b:
    result = a
else:
    result = b
#Данный код, в зависимости от значения переменных а и b, присваивает переменной result значение большей из них.

#Код сравнения занимает аж четыре строки, а выполняет элементарное действие. 
#Это не в стиле Python — нужно исправлять данную ситуацию.
#Для таких случаев существует так называемый тернарный условный оператор — оператор, который записывается в одну строку.

#В Python вы можете встретить «инлайновый if». С его помощью можно переписать код следующим образом:
/Тернарный оператор
result = a if a > b else b
#ИЛИ
result = (b, a)[a > b] - результат равен a, если условие верно. ТОЧНО a, ПРОВЕРИЛ. ХОТЬ И СТОИТ НА 2 МЕСТЕ В СКОБКАХ
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////








/////////////////
///ИСКЛЮЧЕНИЯ///
////////////////
//Конструкция
try:
    *код, который может вызвать ту или иную ошибку*
except *ошибка*:
    *код, который выполнится в случае возникновения ошибки*
else:
    *код, который выполнится только в случае, если в try ничего не сломалось*
finally:
    *код, который выполнится в любом случае*

//Вызов ошибки*
raise ValueError("Invalid Date!")

//Пример
try:
    print("Before exception") # перед исключением
    a = int(input("a: "))
    b = int(input("b: "))
    c = a / b
    print(c) # печатаем c = a / b, если всё хорошо
except ZeroDivisionError as e:
    print("After exception") # после исключения
else: # код в блоке else выполняется только в том случае, если код в блоке try выполнился успешно (т. е. не произошло никакого исключения)
    print("Everything's fine!") # всё отлично!
finally: # код в блоке finally выполнится в любом случае при выходе из try-except
    print("Finally finished!") # наконец-то завершено!
 
print("After After exception") # после после исключения

//Ошибки
#Исключение, возникающее при делении на 0	
ZeroDivisionError

#Ошибка значения	
#При невозможности привести один тип к другому	
ValueError

#Файл не найден	
#Если попытаться открыть файл для чтения, который не был создан	
FileNotFoundError

#Недостаточно прав	
#Если попытаться открыть файл из корневых каталогов при запуске программы не от имени администратора	
PermissionError
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////








///////////////
///ЦИКЛ for///
/////////////
//Конструкция
for value in iterator:
    # Начало блока кода с телом цикла
    ...
    ...
    ...
    # Конец блока кода с телом цикла
# Код, который будет выполняться после цикла

//Пример
S = 0  # создаём переменную-счётчик, в которой будем считать сумму
N = 5

# создаём цикл for, которым мы будем проходить по всем числам от одного до N
for i in range(1, N + 1):  # равносильно выражению for i in [1, 2, 3, ... , N -1, N]:
    print("Sum on the previous step: ", S) # значение суммы на предыдущем шаге
    print("Current number: ", i) # текущее число
    S = S + i  # cуммируем текущее число i и перезаписываем значение суммы
    print("Sum after addition: ", S) # значение суммы после сложения
    print("---")
print("End of the cycle") # конец цикла
print()
print("Answer: sum = ", S) # ответ: сумма равна =
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////







/////////////////
///ЦИКЛ while///
///////////////
//Конструкция
while условие:
    # Начало блока кода с телом цикла
    # пока условие истинно, цикл выполняется
    ...
    ...
    ...
    # Конец блока кода с телом цикла
# Код, который будет выполняться после цикла

//Пример
S = 0  # создаём переменную-счётчик, в которой будем считать сумму
n = 1  # текущее натуральное число

# создаём цикл while, который будет работать, пока сумма не превысит 500
while S < 500:  # делай, пока ...
    S += n  # увеличиваем сумму, равносильно S = S + n
    n += 1  # так как сумма ещё не достигла нужного значения, увеличиваем переменную-счётчик
    print("Still counting ...") # идёт подсчёт

print("Sum is: ", S) # сумма равна
print("Numbers total: ", n-1) # количество чисел
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////








//////////////
///МАТРИЦЫ///
////////////
//Конструкция
for i in range(N): 
    for j in range(M): 
        print(matrix[i][j], end=" ")
    print()  # перенос на новую строку

# 0 1 2
# 3 4 5

#min and max

//Пример
random_matrix = [
   [9, 2, 1],
   [2, 5, 3],
   [4, 8, 5]
]
min_value_rows = []
min_index_rows = []
max_value_rows = []
max_index_rows = []
for row in random_matrix:
    min_index = 0
    min_value = row[min_index]
    max_index = 0
    max_value = row[max_index]
    for index_col in range(len(row)):
        if row[index_col] < min_value: 
            min_value = row[index_col]
            min_index = index_col
        if row[index_col] > max_value: 
            max_value = row[index_col]
            max_index = index_col
    min_value_rows.append(min_value)
    min_index_rows.append(min_index)
    max_value_rows.append(max_value)
    max_index_rows.append(max_index)
print("Minimal elements:", min_value_rows) # минимальные элементы
print("Their indices:", min_index_rows) # их индексы
print("Maximal elements:", max_value_rows) # максимальные элементы
print("Their indices:", max_index_rows) # их индексы
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////







////////////////
///ENUMERATE///
//////////////
#За один проход по циклу for мы можем либо получить само значение из списка, либо индекс, по 
#которому дальше обратимся и получим элемент, как, например, здесь:

list_ = [-5, 2, 4, 8, 12, -7, 5]

for i in range(len(list_)):  # равносильно выражению for i in [0, 1, 2, 3, 4, 5, 6]:
    print("Element index: ", i) # индекс элемента
    print("Element value: ", list_[i])  # с помощью индекса получаем значение элемента
    print("---")
print("End of the cycle") # конец цикла

#Но чтобы убить двух зайцев сразу, есть функция enumerate. 
#Она возвращает кортежи, где на первом месте стоит индекс элемента, а на втором — его значение.

list1 = [-5, 2, 4, 8, 12, -7, 5]
# Функция enumerate возвращает данные в виде кортежей, 
# где на первом месте стоит индекс, а затем значение 

for i, value in enumerate(list1):  
    print("Element index: ", i) # индекс элемента
    print("Element value: ", value)  # с помощью индекса получаем значение элемента
    print("---")
print("End of the cycle") # конец цикла
# [(0, -5), (1, 2), (2, 4), ...] что значит [(i0,value0),(i1,value1),...,(iN,valueN)]
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////







////////////////////
///АНАЛИЗ ТЕКСТА///
//////////////////
#Символы в верхнем и нижнем регистре будем считать одинаковыми, поэтому приведём текст в 
#нижний регистр и удалим все пробелы и символы переноса строки.

count = {}  # для подсчёта символов и их количества
for char in text:
   if char in count:  # если символ уже встречался, увеличиваем его количество на 1
       count[char] += 1
   else:
       count[char] = 1
	   
#Создаём переменную-счётчик в виде словаря, где по ключу будет храниться символ, 
#по значению — его количество. Далее с помощью цикла for посимвольно будем проходиться по обработанному тексту и считать символы:

for char, cnt in count.items():
   print(f"Symbol {char} can be found {cnt} times in the text") #символ {char} встречается в тексте {cnt} раз
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////







/////////////////////
///BREAK/CONTINUE///
///////////////////
#При встрече слова 
break
#цикл прекращается полностью

#При встрече слова 
continue
#цикл прекращает данный круг и переходит к следующему
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////







//////////////
///ФУНКЦИИ///
////////////

//Конструкция
def название функции(аргумент1, ..., аргументN, аргументПоУмолчанию1 = None, ..., *arg, **kwargs) #аргПоУмолч это int, floar, str, bool, None
    # Начало блока кода с телом функции
    pass 	#Дает понять итератору, что функция пока не написана, но объявлена
    ...		#Тут могут находиться переменные, условия, циклы, другие функции и т.д.
    ...
    # Конец блока кода с телом функции
	raise Ошибка("Сообщение об ошибке!") #Вызываем ошибку и прекращаем выполнение функции
	return аргумент1, ..., аргументN #возвращает аргумент(ты) после выполнения функции.

# Код, который будет выполняться после функции

//Учёт типов данных для ускоренного написания документации по функции
def random_predict(number:int=1) -> int:
'''
Обратите внимание, что в аргументах функции мы через двоеточие указываем тип данных для ввода (int), 
через равно — стандартное значение этого типа данных. Стрелка (->) указывает, какой тип данных мы должны 
получить на выходе. Это упростит заполнение документации, а также позволит в дальнейшем эффективнее работать с ошибками.
'''
//Пример
#Извлечение корня
def root(value, n=2):
   result = value ** (1/n)
   return result


/Порядковые аргументы *arg - кортеж. Неизвестное число агрументов
def mean(*numbers):
   result = sum(numbers) / len(numbers)
   return result
 
print(mean(5,4,4,3))
# Будет напечатано
# 4.0

/Именованные аргументы **kwargs - словарь
# В переменную kwargs будут записаны все
# именованные аргументы
def schedule(**kwargs):
   # kwargs — это словарь, проверим это с помощью isinstance:
   print(isinstance(kwargs, dict))
   # Напечатаем объект kwargs
   print(kwargs)
 
schedule(monday='Python', tuesday='SQL', friday='ML')
# Будет напечатано:
# True
# {'monday': 'Python', 'tuesday': 'SQL', 'friday': 'ML'}

//lambda-функции 
/Обычная функция
def root(num):
    # Напоминание: в Python используется оператор **
    # для возведения числа в степень.
    # В математике возведение в степень ½ соответствует
    # вычислению квадратного корня.
    return num ** (1/2)
	
/lambda
# Напоминание: оператор % используется для получения остатка
# от деления. Если остаток от деления на 2 равен 0, то
# число является чётным.
# Обратный слэш (\) используется в Python для того,
# чтобы перенести одну строку кода на следующую строку.
# Получается, что компьютер интерпретирует записанное ниже
# как одну строку.
is_even = lambda num: "even" if num % 2 == 0 \
    else "odd"

/Сортировка через lambda-функции
def sort_registry(registry):
    # Вместо pass напишите тело функции
    registry.sort(key=lambda x:
        (x[-1], x[-2], x[-3], x[0], x[1], x[2]))
    return registry

reg = [('Petrova', 'Maria', 'Ivanovna', 13, 3, 2003),
      ('Ivanov', 'Sergej', None, 24, 9, 1995),
      ('Smith', 'John', None, 13, 2, 2003)]
 
reg = sort_registry(reg)
print(reg)	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////








////////////////////////////
///РАЗРЕШЕНИЕ ПЕРЕМЕННЫХ///
//////////////////////////
#Приоритет переменных
1
Локальные переменные (local) — это переменные, которые были объявлены в функции и используются непосредственно в ней.
local perermennaya = 5

2
Нелокальные переменные (nonlocal) — это переменные, которые были объявлены во внешней функции относительно 
рассматриваемой.
nonlocal perermennaya = 5

3
Глобальные переменные (global) — это переменные, которые были объявлены непосредственно в исходном коде основного скрипта.
global perermennaya = 5

4
Встроенные переменные (built-in) — это переменные и объекты, которые встроены в функционал Python изначально. 
Например, к ним относятся функции print, len, структуры данных list, dict, tuple и другие.
built-in perermennaya = 5

Таким образом, когда интерпретатор встречает в коде функции ссылку на какой-то объект, он начинает 
искать его среди локальных переменных, затем переключается на нелокальные, потом на глобальные и, 
наконец, ищет переменную среди встроенных объектов. Если поиск оказался безрезультатным, возникает ошибка.

→ Однако интерпретатор не всегда проходит весь этот путь самостоятельно. Ему необходимо показать, 
что та или иная переменная является глобальной или нелокальной, если в коде функции происходит 
изменение этой переменной.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////







///////////////
///РЕКУРСИЯ///
/////////////
#Функция может вызывать саму себя. Это часто бывает удобно, но жертвуем быстродействием.

//Конструкция
def название функции(аргумент1, ..., аргументN, аргументПоУмолчанию1 = None, ..., *arg, **kwargs) #аргПоУмолч это int, floar, str, bool, None
    # Задаём условия выхода из рекурсии:
	if первое условие: return 1
    if n-е условие: return 1
	# Когда достигнуто конечное значение, функция начинает "схлапываться"
    pass 	#Дает понять итератору, что функция пока не написана, но объявлена
    ...		#Тут могут находиться переменные, условия, циклы, другие функции и т.д.
    ...
    # Конец блока кода с телом функции
	raise Ошибка("Сообщение об ошибке!") #Вызываем ошибку и прекращаем выполнение функции
	return название #функции Функция вызывает саму себя

# Код, который будет выполняться после функции

//Пример
#Факториал
def factorial(n):
   # Задаём условия выхода из рекурсии:
   if n==0: return 1
   if n==1: return 1
   # Во всех других случаях возвращаем
   # произведение текущего числа n и функции от n-1
   return factorial(n-1)*n
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////







////////////////
///ИТЕРАТОРЫ///
//////////////
#В Python из многих встроенных структур данных (списков, словарей, множеств) можно получать итераторы. 
#Происходит это с помощью функции 
iter().

//Пример
users = ['admin', 'guest', 'root', 'anonymous']
iter_users = iter(users)
 
for user in iter_users:
   print(user)
 
# Будет напечатано:
# admin
# guest
# root
# anonymous
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////







/////////////////
///ГЕНЕРАТОРЫ///
///////////////
#Похож на функцию, но вместо return в генераторе
#используется yield, который также возвращает значение, но также
#запоминает его, и в следующий раз с ним работает 

//Пример
def deposit(money, interest):
   # Процент по вкладу преобразуем во множитель:
   # делим процент на 100 и прибавляем 1
   interest = interest/100 + 1
   while True:
       # Сумма на вкладе через год — это
       # текущая сумма, домноженная на множитель и
       # округлённая до 2 знаков после запятой
       money = round(interest * money, 2)
       yield money
#Как видите, генератор использует ту же сигнатуру, что и функция.

#Будет объект функцией или генератором, определяется наличием оператора yield в коде. 
#Этот оператор также возвращает следующее за ним значение в исходный код основного скрипта, 
#однако интерпретатор запоминает место, на котором он завершил работу с генератором и возвращается 
#на то же место при повторном обращении к генератору. В случае с return повторное выполнение функции 
#произошло бы с самого начала. 

/Списочные сокрощения генераторов
#Создание генератора не как функции, а в одну строку

squares_generator = (x**2 for x in range(1, 11))
 
squares_list = list(squares_generator)
print(squares_list)
# Будет напечатано:
# [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////






5.2
//////////////////////////
///ИТЕРАТОРЫ И ФУНКЦИИ///
////////////////////////
///ФУНКЦИЯ map()

//Конструкция
итератор = map(функция, указатель на итерируемый объект)

//Пример
#Вариант выполнения 1
names = ['Ivan', 'Nikita', 'Simon', 'Margarita', 'Vasilisa', 'Kim']
 
lens = []
 
for name in names:
   length = len(name)
   lens.append(length)
 
print(lens)
# [4, 6, 5, 9, 8, 3]

#Вариант выполнения 2
def get_length(word):
   return len(word)
lens = map(get_length, names)
# Проверим, что переменная lens — это объект типа map:
print(isinstance(lens, map))
# Будет напечатано:
# True
#Объект типа map можно использовать как обычный итератор, то есть применять к нему функцию next():

print(next(lens))
print(next(lens))
print(next(lens))
# Будет напечатано:
# 4
# 6
# 5

#Вариант выполнения 3
lens = list(map(lambda x: len(x), names))
print(lens)
# Будет напечатано:
# [4, 6, 5, 9, 8, 3]


///ФУНКЦИЯ filter()

//Конструкция
итератор = filter(функция(должна возвращать True, указатель на итерируемый объект)

//Пример
#Вариант выполнения 1
def is_even(num):
   if num % 2 == 0:
       return True
   return False
 
even = filter(is_even, [4, 6, 5, 9, 8, 3])
# Убедимся, что even — объект типа filter
print(isinstance(even, filter))
# Будет напечатано:
# True
Объект filter также является итератором. Сохраним все элементы из него в список и напечатаем этот список:

print(list(even))
# Будет напечатано:
# [4, 6, 8]

#Вариант выполнения 2
even = filter(lambda x: x % 2 == 0, [4, 6, 5, 9, 8, 3])
print(list(even))
# Будет напечатано:
# [4, 6, 8]


///Конвейер из map() и filter()

//Пример
#Вариант выполнения 1
names = ['Ivan', 'Nikita', 'Simon', 'Margarita', 'Vasilisa', 'Kim']
count_a = list()
for name in names:
   if len(name) >= 5:
       count_a.append((name, name.upper().count('А')))
print(count_a)
 
# Будет напечатано:
# [('Nikita', 1), ('Simon', 0), ('Margarita', 3), ('Vasilisa', 2)]

#Вариант выполнения 2
names = ['Ivan', 'Nikita', 'Simon', 'Margarita', 'Vasilisa', 'Kim']
# Отбираем имена из 5 и более букв
long_names = filter(lambda x: len(x) >= 5, names)
# Все отобранные имена переводим в верхний регистр и считаем число букв А в них
# Результат сохраняем в виде кортежа (имя, число букв "A")
count_a = map(lambda x: (x, x.upper().count('A')), long_names)
# Переводим объект map в list и печатаем его
print(list(count_a))
 
# Будет напечатано:
# [('Nikita', 1), ('Simon', 0), ('Margarita', 3), ('Vasilisa', 2)]


///ФУНКЦИЯ zip()

//Пример
surnames = ['Ivanov', 'Smirnov', 'Kuznetsova', 'Nikitina']
names = ['Sergej', 'Ivan', 'Maria', 'Elena']
for surname, name in zip(surnames, names):
  print(surname, name)
 
# Будет напечатано:
# Ivanov Sergej
# Smirnov Ivan
# Kuznetsova Maria
# Nikitina Elena
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////






5.2
/////////////////
///ДЕКОРАТОРЫ///
///////////////
#Декораторы — это функции, которые изменяют поведение основной функции таким образом, 
#что она продолжает принимать и возвращать те же значения, однако её функционал расширяется.

//Пример
# Декорирующая функция принимает в качестве
# аргумента название функции
def simple_decorator(func):
 
   # Функция, в которой происходит модификация поведения
   # функции func. Она будет принимать те же аргументы,
   # что и функция func, которую декорирует decorated_function.
   # Чтобы принять все возможные аргументы, используем сочетание
   # *args и *kwargs.
   def decorated_function(*args, **kwargs):
       # Печатаем принятые аргументы
       print("Input:")
       print("Positional:", args)
       print("Named:", kwargs)
       # С помощью конструкции *args/**kwargs
       # считаем результат выполнения функции func
       result = func(*args, **kwargs)
       # Печатаем результат выполнения функции
       print("Result:", result)
       # Не забываем вернуть результат, чтобы
       # не повлиять на поведение декорируемой функции!
       return result
   # Внешняя функция возвращает функцию
   # decorated_function
   return decorated_function

//Сокращение
#В Python декораторы используются довольно часто. Они позволяют значительно упростить жизнь разработчику. 
#Чтобы применять декораторы было удобнее, используется запись названия декоратора через символ @ прямо над сигнатурой основной функции:

@simple_decorator
def root(value, n=2):
   result = value ** (1/n)
   return result

#Такая запись говорит интерпретатору о том, что необходимо применить функцию simple_decorator  к функции root. 
#При этом удобным оказывается то, что название самой декорированной функции от применения декоратора не меняется.

//time()
#Напишем более практичный декоратор. Он будет печатать время работы функции в секундах с помощью функции time() из модуля time:

# Из модуля time импортируем функцию time
from time import time
 
def time_decorator(func):
   def decorated_func(*args, **kwargs):
       # Получаем время на момент начала вычисления
       start = time()
       result = func(*args, **kwargs)
       # Получаем время на момент окончания вычисления
       end = time()
       # Считаем длительность вычисления
       delta = end - start
       # Печатаем время работы функции
       print("Runtime:", delta)
       return result
   return decorated_func
#Применим новый декоратор time_decorator к функции root и несколько раз посчитаем время вычислений:

@time_decorator
def root(value, n=2):
   result = value ** (1/n)
   return result
 
print(root(81))
print(root(81))
print(root(81))
print(root(81))
# Будет напечатано:
# Runtime: 1.9073486328125e-05
# 9.0
# Runtime: 5.245208740234375e-06
# 9.0
# Runtime: 3.814697265625e-06
# 9.0
# Runtime: 2.1457672119140625e-06
# 9.0
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////






9.1
/////////////////////////
///Модуль Collections///
///////////////////////
//Counter
#Счетчик числа различных данных

/
# Импортируем объект Counter из модуля collections
from collections import Counter
# Создаём пустой объект Counter
c = Counter()
#Теперь в переменной c хранится объект с возможностями Counter.

'''
Рассмотрим базовый синтаксис этого инструмента. Например, будем считать 
#цвета проезжающих машин: если встретили красную машину, посчитаем её. 
#Для этого прибавим к ключу 'red' единицу. Синтаксис очень похож на работу со словарём:
'''
c['red'] += 1
print(c)
# Будет напечатано:
# Counter({'red': 1})

'''
Узнать сумму всех значений в объекте Counter можно, воспользовавшись следующей конструкцией:
'''
print(sum(c.values()))
# 9

/Обработка списков
cars = ['red', 'blue', 'black', 'black', 'black', 'red', 'blue', 'red', 'white']

#Посчитать значения, конечно, можно и в цикле, используя синтаксис из предыдущего примера:
c = Counter()
for car in cars:
   c[car] += 1
 
print(c)
# Counter({'red': 3, 'black': 3, 'blue': 2, 'white': 1})

#Однако гораздо проще при создании Counter сразу передать в круглых скобках итерируемый объект, в котором необходимо посчитать значения:
c = Counter(cars)
print(c)
# Counter({'red': 3, 'black': 3, 'blue': 2, 'white': 1})


/Вычитание counter
print(counter_moscow)
print(counter_spb)
# Counter({'black': 4, 'yellow': 3, 'white': 2})
# Counter({'white': 3, 'red': 2, 'black': 2, 'yellow': 2})
 
counter_moscow.subtract(counter_spb)
print(counter_moscow)
# Counter({'black': 2, 'yellow': 1, 'white': -1, 'red': -2})

#Обычное вычитание приводит к другому результату
print(counter_moscow - counter_spb)
# Counter({'black': 2, 'yellow': 1})

/Получение всего списка ключей (элементы возвращаются в алфавитном порядке, а не в хронологии)
print(*counter_moscow.elements())
# black black black black white white yellow yellow yellow

/Чтобы получить список уникальных элементов, достаточно воспользоваться функцией list():
print(list(counter_moscow))
# ['black', 'white', 'yellow']

/С помощью метода dict() можно превратить Counter в обычный словарь:
print(dict(counter_moscow))
# {'black': 4, 'white': 2, 'yellow': 3}

/Метод most_common() позволяет получить список из кортежей элементов в порядке убывания их встречаемости:
print(counter_moscow.most_common())
# [('black', 4), ('yellow', 3), ('white', 2)]

#В неё также можно передать значение, которое задаёт желаемое число первых наиболее частых элементов, например, 2:
print(counter_moscow.most_common(2))
# [('black', 4), ('yellow', 3)]

/Метод clear() позволяет полностью обнулить счётчик:
counter_moscow.clear()
print(counter_moscow)
# Counter()


//defaultdict
#Словарь с заданным типом данных по умолчанию
from collections import defaultdict
groups = defaultdict(list)
#Обратите внимание, что в скобках мы передаём именно указатель на класс объекта (например list; также можно 
#было бы применить set, dict) без круглых скобок, которые используются для создания нового экземпляра объекта.

#Теперь тот же код, который вызывал ошибку при работе с обычным словарём, сработает так, как ожидается:

for student, group in students:
   groups[group].append(student)
 
print(groups)
# defaultdict(<class 'list'>, {1: ['Ivanov', 'Kuznetsova'], 4: ['Smirnov'], 3: ['Petrov', 'Markov'], 2: ['Nikitina', 'Pavlov']})
#В выводе есть небольшое отличие от обычного словаря: печатаются не только элементы словаря, 
#но и само название объекта defaultdict, а также класс объекта, который задан по умолчанию. 
#В данном случае это <class 'list'>. 

#Получить элемент из defaultdict по ключу можно так же, как и из обычного словаря:
print(groups[3])
# ['Petrov', 'Markov']

#Если запрашиваемого ключа нет в словаре, KeyError не возникнет. 
#Вместо этого будет напечатан пустой элемент, который создаётся в словаре по умолчанию:
print(groups[2021])
# []

#Теперь в словаре groups автоматически появился элемент 2021 с пустым списком внутри, 
#несмотря на то что мы его не создавали:
print(groups)
# defaultdict(<class 'list'>, {1: ['Ivanov', 'Kuznetsova'], 4: ['Smirnov'], 3: ['Petrov', 'Markov'], 2: ['Nikitina', 'Pavlov'], 2021: []})

#Итак, вы обратили внимание, что поведение defaultdict в коде отличается от обычного словаря dict. 
#Узнать, с каким именно словарём мы имеем дело в коде, можно с помощью встроенной функции type:

dict_object = dict()
defaultdict_object = defaultdict()
 
print(type(dict_object))
# <class 'dict'>
print(type(defaultdict_object))
# <class 'collections.defaultdict'>

/Примерэ
students = [('Ivanov',1),('Smirnov',4),('Petrov',3),('Kuznetsova',1),
            ('Nikitina',2),('Markov',3),('Pavlov',2)]

from collections import defaultdict
groups = defaultdict(list)

for student, group in students:
   groups[group].append(student)
 
print(groups)
# defaultdict(<class 'list'>, {1: ['Ivanov', 'Kuznetsova'], 4: ['Smirnov'], 3: ['Petrov', 'Markov'], 2: ['Nikitina', 'Pavlov']})

//deque ("дэк")
#Очередь - первым пришёл, первым ушёл
#Стек(рюкзак) - последним пришёл, первым ушёл
#Инструмент для работы с очередями элементов
'''
Можно сказать, что стек и очередь — это принципы обработки данных. deque позволяет 
обрабатывать данные обоими способами в зависимости от того, что требуется от разработчика. 
В каком порядке обрабатывать данные (FIFO или LIFO) вам подскажет собственная логика или более 
продвинутая теория алгоритмов, которая в данном модуле не изучается.
'''
from collections import deque
dq = deque()
print(dq)
# deque([])
/У deque есть четыре ключевые метода:
- append (добавить элемент в конец дека);
- appendleft (добавить элемент в начало дека);
- pop (удалить и вернуть элемент из конца дека);
- popleft (удалить и вернуть элемент из начала дека).

Также в очередь возможно добавить сразу несколько элементов из итерируемого объекта в дек. 
- extend (добавить в конец дека)
- extendleft (добавить в начало дека)

/ОЧЕРЕДЬ С ОГРАНИЧЕННОЙ МАКСИМАЛЬНОЙ ДЛИНОЙ
#При создании очереди можно также указать её максимальную длину с помощью параметра maxlen. Сделать это можно как при создании пустой очереди, так и при создании очереди от заданного итерируемого объекта:
limited = deque(maxlen=3)
print(limited)
# deque([], maxlen=3)
limited_from_list = deque([1,3,4,5,6,7], maxlen=3)
print(limited_from_list)
# deque([5, 6, 7], maxlen=3)

#Обратите внимание, что теперь дополнительно печатается максимальная длина очереди.
#Также заметьте, что в очереди с ограниченной длиной сохраняются только последние элементы, а первые исчезают из памяти:
limited.extend([1,2,3])
print(limited)
# deque([1, 2, 3], maxlen=3)
 print(limited.append(8))
# None
print(limited)
# deque([2, 3, 8], maxlen=3)
#При этом, как видно из результата операции limited.append(8), удаляемый элемент не возвращается, а просто исчезает.

/reverse позволяет поменять порядок элементов в очереди на обратный:
dq = deque([1,2,3,4,5])
print(dq)
# deque([1, 2, 3, 4, 5])
 
dq.reverse()
print(dq)
# deque([5, 4, 3, 2, 1])

/rotate переносит  заданных элементов из конца очереди в начало:
dq = deque([1,2,3,4,5])
print(dq)
# deque([1, 2, 3, 4, 5])
 dq.rotate(2)
print(dq)
# deque([4, 5, 1, 2, 3])

Элементы можно переносить и из начала в конец:
dq = deque([1,2,3,4,5])
print(dq)
# deque([1, 2, 3, 4, 5])
# Отрицательное значение аргумента переносит
# n элементов из начала в конец
dq.rotate(-2)
print(dq)
# deque([3, 4, 5, 1, 2])

/index позволяет найти первый индекс искомого элемента, а count позволяет подсчитать, сколько раз элемент встретился в очереди (функции аналогичны одноимённым функциям для списков):
dq = [1,2,4,2,3,1,5,4,4,4,4,4,3]
print(dq.index(4))
# 2
print(dq.count(4))
# 6

/clear позволяет очистить очередь:
dq = deque([1,2,4,2,3,1,5,4,4,4,4,4,3])
print(dq)
# deque([1, 2, 4, 2, 3, 1, 5, 4, 4, 4, 4, 4, 3])
dq.clear()
print(dq)
# deque([])

//OrderedDict нужен до версии питона 3.7
#Словарь, который гарантирует сохранение порядка добавления ключей в нём
from collections import OrderedDict
data = [('Ivan', 19),('Mark', 25),('Andrey', 23),('Maria', 20)]
ordered_client_ages = OrderedDict(data)
print(ordered_client_ages)
# По результатам 3 повторов получились вот такие результаты:
# OrderedDict([('Ivan', 19), ('Mark', 25), ('Andrey', 23), ('Maria', 20)])
# OrderedDict([('Ivan', 19), ('Mark', 25), ('Andrey', 23), ('Maria', 20)])
# OrderedDict([('Ivan', 19), ('Mark', 25), ('Andrey', 23), ('Maria', 20)])

#Можно, например, отсортировать с помощью функции sorted список кортежей при создании из него OrderedDict, 
#и объекты будут добавлены в порядке сортировки:
#sorted(iterable,key=None,reverse=False)
data = [('Ivan', 19),('Mark', 25),('Andrey', 23),('Maria', 20)]
# Сортируем по второму значению из кортежа, то есть по возрасту
ordered_client_ages = OrderedDict(sorted(data, key=lambda x: x[1]))
print(ordered_client_ages)
# OrderedDict([('Ivan', 19), ('Maria', 20), ('Andrey', 23), ('Mark', 25)])
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////






9.5
////////////
///NumPy///
//////////
import numpy as np
Могла возникнуть ошибка:

ModuleNotFoundError: No module named 'numpy'
Это означает, что модуль NumPy пока не установлен. Чтобы его установить, необходимо выполнить следующую команду в командной строке (для установки библиотеки через встроенный в Anaconda менеджер пакетов conda):

conda install numpy
Если вдруг вы окажетесь за компьютером, где есть только Python, но нет Anaconda, библиотеку NumPy можно установить через стандартный для Python менеджер пакетов — pip:

pip install numpy

//ОСОБЕННОСТИ
в NumPy int по умолчанию становится int64, если не указано иное количество выделенной памяти.

print(*sorted(map(str, set(np.sctypeDict.values()))), sep='\n')
Всего в выдаче будет 24 строки. Int, uint и float мы уже изучили. 
Datetime и timedelta используются для хранения времени, complex используется для работы с комплéксными числами.

/Узнать границы
# Можно применить к самому
# названию типа данных
np.iinfo(np.int8)
# iinfo(min=-128, max=127, dtype=int8)

# Можно применить к существующему
# конкретному объекту
np.iinfo(a)
# iinfo(min=-128, max=127, dtype=int8)

/Небольшое замечание про bool: несмотря на то что для хранения значения истина/ложь было бы достаточно только 
одного бита, из-за особенностей работы с памятью компьютера булевая переменная всё равно занимает в памяти целый байт.

//ЦЕЛОЧИСЛЕННЫЕ ТИПЫ ДАННЫХ В NUMPY
Это тип данных с общим корнем int. Int может быть со следующими окончаниями: int8, int16, int32 и int64. Окончание типа данных в NumPy показывает, сколько битов памяти должно быть выделено для хранения переменной.

Преобразуем обычное целое число в NumPy-тип, например в int8. Для этого напишем выражение np.int8 и круглые скобки. В круглых скобках в качестве аргумента передадим тот объект, который должен быть преобразован:

import numpy as np
a = np.int8(25)
print(a)
# 25
print(type(a))
# <class 'numpy.int8'>

/Узнать границы
# Можно применить к самому
# названию типа данных
np.iinfo(np.int8)
# iinfo(min=-128, max=127, dtype=int8)

# Можно применить к существующему
# конкретному объекту
np.iinfo(a)
# iinfo(min=-128, max=127, dtype=int8)

Доступны следующие типы данных int: 
int8, int16, int32, int64 (применяется по умолчанию, если объём памяти не задан дополнительно).
np.iinfo(np.int8)
# min = -128 max = 127
np.iinfo(np.int16)
# min = -32768 max = 32767
np.iinfo(np.int32)
# min = -2147483648 max = 2147483647
np.iinfo(np.int64)
# min = -9223372036854775808 max = 9223372036854775807

//БЕЗЗНАКОВЫЕ ЦЕЛОЧИСЛЕННЫЕ ТИПЫ ДАННЫХ В NUMPY
В NumPy доступны и беззнаковые целочисленные типы данных. Они имеют корень uint (unsigned int — беззнаковое целое). 
uint доступны также с выделением памяти в 8, 16, 32 и 64 бита. При этом максимально возможное число оказывается в 
два раза больше, чем для соответствующего int, поскольку отрицательные числа исключены из типа данных uint.
b = np.uint8(124)
print(b)
# 124
print(type(b))
# <class 'numpy.uint8'>
np.iinfo(b)
# iinfo(min=0, max=255, dtype=uint8)

//ТИПЫ ДАННЫХ С ПЛАВАЮЩЕЙ ТОЧКОЙ В NUMPY
Беззнаковых float нет.
Доступны следующие типы данных float: 
float16, float32, float64 (применяется по умолчанию, если объём памяти не задан дополнительно), float128.
np.finfo(np.float16)
# finfo(resolution=0.001, min=-6.55040e+04, max=6.55040e+04, dtype=float16)
np.finfo(np.float32)
# finfo(resolution=1e-06, min=-3.4028235e+38, max=3.4028235e+38, dtype=float32)
np.finfo(np.float64)
# finfo(resolution=1e-15, min=-1.7976931348623157e+308, max=1.7976931348623157e+308, dtype=float64)
np.finfo(np.float128)
# finfo(resolution=1e-18, min=-1.189731495357231765e+4932, max=1.189731495357231765e+4932, dtype=float128)

//bool_ and str_
Следует обратить внимание на типы данных bool_ и str_. Они аналогичны bool и str из встроенных в Python, 
однако записывать их необходимо именно с нижним подчёркиванием, иначе произойдёт приведение к стандартному 
типу данных, а не типу NumPy. В целом, существенной разницы между этими типами данных нет, однако о такой
 двойственности следует помнить при сравнении типов переменных: тип bool не является эквивалентным numpy.bool_, 
 несмотря на то что оба типа данных хранят значения True или False.

Пример с bool:
a = True
print(type(a))
# <class 'bool'>
a = np.bool(a)
print(type(a))
# <class 'bool'>
a = np.bool_(a)
print(type(a))
# <class 'numpy.bool_'>
 
# Значения равны
print(np.bool(True) == np.bool_(True))
# True
# А типы — нет:
print(type(np.bool(True)) == type(np.bool_(True)))
# False

Пример со str:
a = "Hello world!"
print(type(a))
# <class 'str'>
a = np.str(a)
print(type(a))
# <class 'str'>
a = np.str_(a)
print(type(a))
# <class 'numpy.str_'>

//МАССИВЫ
#Итак, массив — это структура данных, в которой:
1 Элементы хранятся в указанном порядке.
2 Каждый элемент можно получить по индексу за одинаковое время.
3 Все элементы приведены к одному и тому же типу данных.
4 Максимальное число элементов и объём выделенной памяти заданы заранее.
#3x5 — у этой таблицы две размерности: 3 строки и 5 столбцов.

/СОЗДАНИЕ МАССИВА ИЗ СПИСКА
Создать массив из списка можно с помощью функции np.array(<объект>):
import numpy as np
arr = np.array([1,5,2,9,10])
arr
# array([ 1,  5,  2,  9, 10])
Функция np.array возвращает объекты типа numpy.ndarray:
print(type(arr))
# <class 'numpy.ndarray'>

/Давайте теперь создадим двумерный массив из списка списков. 
Его также можно назвать таблицей чисел или матрицей. Сделаем это с помощью той же функции np.array():

# Перечислить список из списков можно
# было и в одну строку, но на нескольких
# строках получается нагляднее
nd_arr = np.array([
               [12, 45, 78],
               [34, 56, 13],
               [12, 98, 76]
               ])
nd_arr
# array([[12, 45, 78],
#        [34, 56, 13],
#        [12, 98, 76]])


/ТИПЫ ДАННЫХ В МАССИВЕ

Мы только что узнали, что массив — это набор однотипных данных, но не указали никакой тип. Какого типа данные хранятся теперь в массиве arr? Узнать это можно, напечатав свойство dtype:

arr = np.array([1,5,2,9,10])
arr.dtype
# dtype('int64')

#Задать тип данных сразу при создании массива можно с помощью параметра dtype:
arr = np.array([1,5,2,9,10], dtype=np.int8)
arr
# array([ 1,  5,  2,  9, 10], dtype=int8)

#Поменять тип данных во всём массиве можно с помощью тех же функций, 
#которыми мы пользовались для преобразования типов отдельных переменных в предыдущем юните (например, np.int32 или np.float128):
arr = np.float128(arr)
arr
# array([ 1.,  5., 12.,  9., 10.], dtype=float128)

//Свойства массивов
print(array.dtype) #Узнать тип данных массива
print(array.ndim) #Узнать размерность массива
print(array.size) #Узнать общее число элементов массива
print(array.shape) #Форма или структура массива (6, 5, 7) - оси массива
print(array.itemsize) #Узнать сколько весит элемент массива
array = np.sort(mystery) #Сортировка массива
/Пустой массиваСоздадим одномерный массив из пяти элементов:
zeros_1d = np.zeros(5)
zeros_1d
# array([0., 0., 0., 0., 0.])

Создадим трёхмерный массив с формой 5x4x3 и типом float32:
zeros_3d = np.zeros((5,4,3), dtype=np.float32)
print(zeros_3d.shape)
# (5, 4, 3)

/задание массивов
#Ещё одной удобной функцией для создания одномерных массивов является arange. 
#Она аналогична встроенной функции range, но обладает рядом особенностей. 
#Вот её сигнатура: 

arange([start,] stop[, step,], dtype=None)

Аргументы start (по умолчанию 0), step (по умолчанию 1) и dtype (определяется автоматически) являются необязательными:
start (входит в диапазон возвращаемых значений) задаёт начальное число;
stop (не входит в диапазон возвращаемых значений, как и при использовании range) задаёт правую границу диапазона;
step задаёт шаг, с которым в массив добавляются новые значения.
В отличие от range, в функции arange все перечисленные параметры могут иметь тип float.
sample = np.arange(1, 101)
#[1,2,3....,99,100]


/На самом деле операции с плавающей точкой не всегда бывают предсказуемыми из-за особенностей хранения таких чисел в памяти компьютера. Поэтому для работы с дробными параметрами start, stop и step лучше использовать функцию linspace (англ. linear space — линейное пространство). Она тоже возвращает одномерный массив из чисел, расположенных на равном удалении друг от друга между началом и концом диапазона, но обладает немного другим поведением и сигнатурой:

np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)

start и stop являются обязательными параметрами, задающими начало и конец возвращаемого диапазона;
num — параметр, задающий число элементов, которое должно оказаться в массиве (по умолчанию 50);
endpoint — включён или исключён конец диапазона (по умолчанию включён);
dtype — уже хорошо знакомый нам параметр, задающий тип данных (если не задан, определяется автоматически);
retstep (по умолчанию False) позволяет указать, возвращать ли использованный шаг между значениями, помимо самого массива.
Давайте потренируемся. Создадим массив из десяти чисел между 1 и 2:

arr = np.linspace(1, 2, 10)
arr
# array([1.        , 1.11111111, 1.22222222, 1.33333333, 1.44444444,
#        1.55555556, 1.66666667, 1.77777778, 1.88888889, 2.        ])

Узнаем, какой шаг был использован для создания массива из десяти чисел между 1 и 2, где 2 включалось и не включалось:

arr, step = np.linspace(1, 2, 10, endpoint=True, retstep=True)
print(step)
# 0.1111111111111111

arr, step = np.linspace(1, 2, 10, endpoint=False, retstep=True)
print(step)
# 0.1

//ДЕЙСТВИЯ С МАССИВАМИ
/ИЗМЕНЕНИЕ ФОРМЫ МАССИВА
Создадим массив из восьми чисел:
import numpy as np
arr = np.arange(8)
arr
# array([0, 1, 2, 3, 4, 5, 6, 7])

Поменять форму массива arr можно с помощью присвоения атрибуту shape кортежа с желаемой формой:
arr.shape = (2, 4) #.reshape((2, 4)) - не меняет массив, а создает новый
arr
# array([[0, 1, 2, 3],
#        [4, 5, 6, 7]])

'''
У функции reshape есть дополнительный именованный аргумент order. 
Он задаёт принцип, по которому элементы заполняют массив новой формы. 
Если order='C' (по умолчанию), массив заполняется по строкам, как в примере выше. 
Если order='F', массив заполняется числами по столбцам:'''
arr = np.arange(8)
arr_new = arr.reshape((2, 4), order='F')
arr_new
# array([[0, 2, 4, 6],
#       [1, 3, 5, 7]])

#Ещё одной часто используемой операцией с формой массива (особенно двумерного) является транспонирование. 
Эта операция меняет строки и столбцы массива местами. В NumPy эту операцию совершает функция transpose.
Будем работать с двумерным массивом:
arr = np.arange(8)
arr.shape = (2, 4)
arr
# array([[0, 1, 2, 3],
#        [4, 5, 6, 7]])

Транспонируем его:
arr_trans = arr.transpose()
arr_trans
# array([[0, 4],
#        [1, 5],
#        [2, 6],
#        [3, 7]])

/ИНДЕКСЫ И СРЕЗЫ В МАССИВАХ
array[0][1] == array[0, 1] - в массивах удобнее обращаться к элементам
можно и срезами array[2:4, 5]

/СОРТИРОВКА МАССИВОВ
#Способ 1. Функция np.sort(<массив>) возвращает новый отсортированный массив:
arr = np.array([23,12,45,12,23,4,15,3])
arr_new = np.sort(arr)
print(arr)
# [23 12 45 12 23  4 15  3]
print(arr_new)
# [ 3  4 12 12 15 23 23 45]

#Способ 2. Функция <массив>.sort() сортирует исходный массив и возвращает None:
arr = np.array([23,12,45,12,23,4,15,3])
print(arr.sort())
# None
print(arr)
# [ 3  4 12 12 15 23 23 45]

//РАБОТА С ПРОПУЩЕННЫМИ ДАННЫМИ
Отличие 1. None является отдельным объектом типа NoneType. np.nan — это отдельный представитель класса float:
print(type(None))
# <class 'NoneType'>
print(type(np.nan))
# <class 'float'>
type(np.nan)

Отличие 2. None могут быть равны друг другу, а np.nan — нет:
print(None == None)
# True
print(np.nan == np.nan)
# False
Как вы помните, чтобы грамотно сравнить что-либо с None, необходимо использовать оператор is. 
Это ещё более актуально для np.nan. Однако None даже через is не является эквивалентным np.nan:
print(None is None)
# True
print(np.nan is np.nan)
# True
print(np.nan is None)
# False

/ОБХОД ПРОПУЩЕННЫХ ДАННЫХ
np.isnan(roots)
# array([False, False,  True, False])
roots[np.isnan(roots)] = 0
roots
# array([2.        , 3.        , 0.        , 1.73205081])

//ВЕКТОРЫ В NUMPY И АРИФМЕТИКА
#Вектор - одномерный массив
/Арифметика - для векторов одинаковой длины
import numpy as np
vec1 = np.array([2, 4, 7, 2.5])
vec2 = np.array([12, 6, 3.6, 13])
print(vec1 + vec2)          #сложение
#[14. , 10. , 10.6, 15.5]
print(vec1 - vec2)          #вычитание
#[-10.   -2.    3.4 -10.5]
print(vec1 * vec2)          #поэлементное умножение
#[ 24.   24.   25.2  32.5]
print(vec1 * 2)             #умножение на число
#[  4.   8.  14.   5.]
print(vec1 > vec2)          #логические операции
#[False False  True False]
print(vec1 < 4)             #сравнения
[ True False False  True]

#Длина вектора 						\[length = \sqrt{x_{1}^{2} + x_{2}^{2} + ... + x_{n}^{2}}\]
vec = np.array([3, 4])
print(vec)
#[3 4]
length = np.sqrt(np.sum(vec ** 2))  
print(length)
# 5.0

#длина вектора с помощью подмодуля linalg
length = np.linalg.norm(vec)        
print(length)
# 5.0

#Расстояние м/ж векторами 			\[distance = \sqrt{(x_1 - y_1)^2 + (x_2 - y_2)^2 + ... + (x_n - y_n)^2}\]
vec1 = np.array([0, 3, 5])
vec2 = np.array([12, 4, 7])
distance = np.linalg.norm(vec1 - vec2)
distance
# 12.206555615733702

#Скалярное произведение векторов 	\[X * Y = x_1 * y_1 + x_2 * y_2 + ... + x_n * y_n\]
#Равенство скалярного произведения нулю означает перпендикулярность рассматриваемых векторов
scalar_product = np.dot(vec1, vec2)
scalar_product
# 250.0

/БАЗОВЫЕ СТАТИСТИЧЕСКИЕ ФУНКЦИИ ДЛЯ ВЕКТОРОВ
vec = np.array([2,7,18,28,18,1,8,4])
vec.min() или min(vec)			#минимаьное
# 1
vec.max() или max(vec)			#максимальное
# 28
vec.mean()			#среднее значение
# 10.75
np.median(vec)		#Среднее медианное
# 7.5
np.std(vec)
# 8.95474734429		#Стандартное отклонение

//СЛУЧАЙНЫЕ ЧИСЛА
/ПОДМОДУЛЬ random_matri
import numpy as np
np.random.rand()
# 0.06600758835806675
Например, получим массив из пяти случайных чисел:
np.random.rand(5)
# array([0.83745099, 0.58426808, 0.89206204, 0.41149807, 0.42445145])

Массив из двух случайных строк и трёх столбцов:
np.random.rand(2, 3)
# array([[0.94931212, 0.06680018, 0.26707599],
#      [0.67908873, 0.18001743, 0.97732239]])

В NumPy есть и другая функция, генерирующая массивы случайных чисел от 0 до 1, 
которая принимает в качестве аргумента именно кортеж без распаковки. Она называется sample:
shape = (2, 3)
np.random.sample(shape)
# array([[0.39756103, 0.01995168, 0.2768951 ],
#       [0.82195372, 0.26435273, 0.00957881]])
Возможно, именно функция sample покажется вам удобнее, поскольку информацию о форме 
массива обычно удобнее хранить в коде в виде кортежа и не задумываться потом о его распаковке. 
В остальном функция sample не отличается от rand.

/Задание чисел по диапазонам
uniform(low=0.0, high=1.0, size=None)
Первые два аргумента — нижняя и верхняя границы диапазона в формате float, третий опциональный аргумент — форма массива 
(если не задан, возвращается одно число). 
Форма массива задаётся кортежем или одним числом.

Давайте поэкспериментируем ↓
Запуск без аргументов эквивалентен работе функций rand или sample:
np.random.uniform()
# 0.951557685543591

Зададим границы диапазона от -30 до 50:
np.random.uniform(-30, 50)
# 38.47365525953661

Получим пять чисел в интервале от 0.5 до 0.75:
np.random.uniform(0.5, 0.75, size=5)
# array([0.58078945, 0.58860342, 0.73790553, 0.63448265, 0.70920297])

Получим массив из двух строк и трёх столбцов из чисел в интервале от -1000 до 500:
np.random.uniform(-1000, 500, size=(2, 3))
# array([[ 129.22164163,   77.69090611, -132.9656972 ],
#        [  18.65802226, -317.14793906,   85.3613547 ]])

/ГЕНЕРАЦИЯ INT

Не всегда требуется генерировать числа с плавающей точкой. 
Иногда бывает удобно получить целые числа int (например, для поля игры в лото). 
Для генерации целых чисел используется функция random.randint:

randint(low, high=None, size=None, dtype=int)

Функцию randint нельзя запустить совсем без параметров, необходимо указать хотя бы одно число.
#Если указан только аргумент low, числа будут генерироваться от 0 до low-1, то есть верхняя граница не включается.
#Если задать low и high, числа будут генерироваться от low (включительно) до high (не включительно).
#size задаёт форму массива уже привычным для вас образом: одним числом — для одномерного или кортежем — для многомерного.
#dtype позволяет задать конкретный тип данных, который должен быть использован в массиве.

np.random.randint(6, 12, size=(3,3))
# array([[ 9,  6, 10],
#        [10, 11, 10],
#        [ 7, 10, 11]])

/ГЕНЕРАЦИЯ ВЫБОРОК
Просто перемешать все числа в массиве позволяет функция random.shuffle.
arr = np.arange(6)
print(arr)
# [0 1 2 3 4 5]
print(np.random.shuffle(arr))
# None
arr
# array([0, 5, 1, 3, 2, 4])

Функция random.shuffle перемешивает тот массив, к которому применяется, и возвращает None.

→Чтобы получить новый перемешанный массив, а исходный оставить без изменений, можно использовать функцию random.permutation. 
Она принимает на вход один аргумент — или массив целиком, или одно число:
playlist = ["The Beatles", "Pink Floyd", "ACDC", "Deep Purple"]
shuffled = np.random.permutation(playlist)
print(shuffled)
# ['The Beatles' 'Pink Floyd' 'Deep Purple' 'ACDC']
print(playlist)
# ['The Beatles', 'Pink Floyd', 'ACDC', 'Deep Purple']
Обратите внимание, что необязательно передавать в функцию сразу массив: 
в этот раз мы передали в качестве аргумента список и ошибки не возникло. 
При этом на выходе получился уже NumPy-массив (это заметно по отсутствию запятых при печати массива). 
Сам список playlist при этом остался без изменений.
Можно генерить массивы
np.random.permutation(10)
# array([7, 8, 2, 9, 4, 3, 1, 0, 5, 6])

Чтобы получить случайный набор объектов из массива, используется функция random.choice:
np.random.choice(a, size=None, replace=True)
#a — массив или число для генерации arange(a);
#size — желаемая форма массива (число для получения одномерного массива, кортеж — для многомерного; если параметр не задан, возвращается один объект);
#replace — параметр, задающий, могут ли элементы повторяться (по умолчанию могут).

workers = ['Ivan', 'Nikita', 'Maria', 'John', 'Kate']
choice = np.random.choice(workers, size=2, replace=False)
print(choice)

/SEED ГЕНЕРАТОРА ПСЕВДОСЛУЧАЙНЫХ ЧИСЕЛ
seed - зерно. Это то, на основе чего работает генератор случайных чисел
По умолчанию оно берется само компьютером.
Самостоятельно задать seed в NumPy можно с помощью функции np.random.seed(<np.uint32>). 
Число в скобках должно быть в пределах от 0 до 2**32 - 1 (=4294967295).
Зададим seed и посмотрим, что получится:
np.random.seed(23)
np.random.randint(10, size=(3,4))
# array([[3, 6, 8, 9],
#        [6, 8, 7, 9],
#        [3, 6, 1, 2]])









/////////////////////////////////////////////////////////////////////////////////////////////////////////////////






10.1
/////////////
///PANDAS///
///////////
#→ Pandas является наиболее продвинутой и быстроразвивающейся библиотекой для анализа данных и их предобработки.
#«Анализ данных начинается с импорта Pandas»
Установка
pip install pandas

Импорт
import pandas as pd
pd.__version__ 			#Проверка
'1.0.5'

//Series
pandas.Series (серия, ряд).
Series — это упорядоченная изменяемая коллекция объектов, имеющая так называемые ассоциативные метки (индексы). 
→ Series в какой-то степени является единицей хранения информации в Pandas. 
Её можно рассматривать как именованный столбец таблицы с индексами строк.

/Создание Series
Способ 1 — из списка с использованием параметров функции pd.Series():
countries = pd.Series(
    data = ['Англия', 'Канада', 'США', 'Россия', 'Украина', 'Беларусь', 'Казахстан'],
    index = ['UK', 'CA', 'US', 'RU', 'UA', 'BY', 'KZ'],
    name = 'countries'
)
display(countries)
'''
UK       Англия
CA       Канада
US          США
RU       Россия
UA      Украина
BY     Беларусь
KZ    Казахстан
Name: countries, dtype: object
'''

Способ 2 — из словаря, в котором ключами являются будущие метки, а значениями — 
будущие значения Series, при этом использование параметра name также возможно:
countries = pd.Series({
    'UK': 'Англия',
    'CA': 'Канада',
    'US' : 'США',
    'RU': 'Россия',
    'UA': 'Украина',
    'BY': 'Беларусь',
    'KZ': 'Казахстан'},
    name = 'countries'
)
display(countries)
'''
UK       Англия
CA       Канада
US          США
RU       Россия
UA      Украина
BY     Беларусь
KZ    Казахстан
Name: countries, dtype: object
'''

/ДОСТУП К ДАННЫМ В SERIES (.loc[] and .iloc[])
print(countries.loc['US']) #Доступ по индексу
# Можно и через print(countries['US'])
# США
print(countries.iloc[6])	#Доступ по номеру индекса (с 0)
# Можно и через print(countries[6])
# Казахстан

//DataFrame Таблица
Примечание. В дальнейшем слова DataFrame и таблица будут употребляться как синонимы. 
Также синонимами в Data Science являются слова признак и столбец таблицы.

/Создание DataFrame
	A	B
0	0	1
1	1	0


СПОСОБ 1
Самый простой способ создания DataFrame — из словаря, ключами которого являются имена 
столбцов будущей таблицы, а значениями — списки, в которых хранится содержимое этих столбцов:
pd.DataFrame({'А': [0, 1], 'B': [1, 0]})

countries_df = pd.DataFrame({
    'country': ['Англия', 'Канада', 'США', 'Россия', 'Украина', 'Беларусь', 'Казахстан'],
    'population': [56.29, 38.05, 322.28, 146.24, 45.5, 9.5, 17.04],
    'square': [133396, 9984670, 9826630, 17125191, 603628, 207600, 2724902]
},
	index = ['UK', 'CA', 'US', 'RU', 'UA', 'BY', 'KZ']
)
display(countries_df)

СПОСОБ 2
Также DataFrame можно создать из вложенного списка, внутренние списки которого будут являться строками новой таблицы:
pd.DataFrame([[0,1], [1, 0]], columns=['А', 'B'])

countries_df = pd.DataFrame(
    data = [
        ['Англия', 56.29, 133396],
        ['Канада', 38.05, 9984670],
        ['США', 322.28, 9826630],
        ['Россия', 146.24, 17125191],
        ['Украина', 45.5, 603628],
        ['Беларусь', 9.5, 207600],
        ['Казахстан', 17.04, 2724902]
    ],
    columns= ['country', 'population', 'square'],
    index = ['UK', 'CA', 'US', 'RU', 'UA', 'BY', 'KZ']
)
display(countries_df)
#		columns 
#index	data
В данном варианте создания DataFrame мы задаём имена столбцов в списке с помощью параметра columns, 
а также инициализируем параметр index для задания меток стран.

/AXIS В DATAFRAME
Так как можно работать и со строками, и со столбцами
используют оси (asix)
asix = 0 #строки
asix = 1 #столбцы

/Обращение к элементам DataFrame
countries_df.population 	#По имени столбцам
countries_df['population']	#По индексу

//ЗАПИСЬ В CSV-ФАЙЛ
countries_df.to_csv('C:\Python\countries.csv', sep=';', decimal='.', index=True, ...)
path_or_buf — путь до файла, в который будет записан DataFrame (например, data/my_data.csv);
sep(seporator) — разделитель данных в выходном файле (по умолчанию ',');
decimal — разделитель чисел на целую и дробную части в выходном файле (по умолчанию '.');
columns — список столбцов, которые нужно записать в файл (по умолчанию записываются все столбцы);
index — параметр, определяющий, требуется ли создавать дополнительный столбец с индексами строк 
в файле (по умолчанию True).

//ЧТЕНИЕ CSV-ФАЙЛА
countries_data = pd.read_csv('C:\Python\countries.csv', sep=';', decimal='.', skiprows = 20)
ufo_data = pd.read_csv('C:\\Python\\ufo.csv', sep=',') #Удвоение обратной черты используется
    #для обхода ошибок связанных с неверным чтением команд \n,\u...
filepath_or_buffer — путь до файла, который мы читаем;
sep(seporator) — разделитель данных (по умолчанию ',');
decimal — разделитель чисел на целую и дробную часть в выходном файле (по умолчанию '.');
names — список с названиями столбцов для чтения;
skiprows — количество строк в файле, которые нужно пропустить (например, файл может содержать 
служебную информацию, которая нам не нужна).

//ЗАПИСЬ И ЧТЕНИЕ В ДРУГИХ ФОРМАТАХ
/Методы для записи таблиц в файлы отличных от csv форматов:
to_excel() — запись DataFrame в формат Excel-таблицы (.xslx);
to_json() — запись DataFrame в формат JSON (.json);
to_xml() — запись DataFrame в формат XML-документа (.xml);
to_sql() — запись DataFrame в базу данных SQL (для реализации этого метода 
необходимо установить соединение с базой данных).
.
/Методы для чтения таблиц из файлов в отличных от csv форматах:
read_excel() — чтение из формата Excel-таблицы(.xslx) в DataFrame;
read_json() — чтение из формата JSON (.json) в DataFrame;
read_xml() — чтение из формата XML-документа (.xml) в DataFrame;
read_sql() — чтение из базы данных SQL в DataFrame (также необходимо установить соединение с базой данных).

//Вывод n-го числа строк (по умолчанию 5)
display(melb_data.head(n))  #Вывод n первых строк
display(melb_data.tail(n))  #Вывод n послежних строк
display(melb_data.shape)    #Вывод размерности


//Работа с таблицей
display(melb_data.info())   #Получение информации о столбцах
melb_data['Postcode'] = melb_data['Postcode'].astype('int64') #Преобразование типа данных столбца

//Получение описательной статистики
'''По умолчанию метод работает с числовыми (int64 и float64) столбцами и показывает число непустых 
значений (count), среднее (mean), стандартное отклонение (std), минимальное значение (min),  
квартили уровней 0.25, 0.5 (медиана) и 0.75 (25%, 50%, 75%) и максимальное значение (max) для 
каждого столбца исходной таблицы.'''
melb_data.describe().loc[:, ['Distance', 'BuildingArea' , 'Price']] #Для числовых значений
melb_data.describe(include=['object'])                              #Для других значеий
melb_data['Regionname'].value_counts() #Получение частоты встречаемых уникальных объектов
melb_data['Regionname'].value_counts(normalize=True) #Получение частоты в относительных значениях (долях)(%)

//Агрегирующие методы
Агрегирующим в Pandas называется метод, который для каждого столбца возвращает только одно 
значение — показатель (например, вычисление медианы, максимума, среднего и так далее).

Параметры методов:
axis  — определяет, подсчитывать параметр по строкам или по столбцам;
numeric_only — определяет, вычислять параметры только по числовым столбцам/строкам или нет (True/False).
.count()    	#Количество непустых значений
.mean()	        #Среднее значение
.median()       #Медиана (среднее)
.min()	        #Минимальное значение
.max()	        #Максимальное значение
.deviance()	    #Дисперсия
.std()	        #Стандартное отклонение
.sum()	        #Сумма
.quantile(x)	#Квантиль уровня x
.nunique()	    #Число уникальных значений
.mode()         #Мода - самое распрастраненное значение (может возвращать несколько)

//Фильтрация данных в DataFrame
Под фильтрацией в DataFrame подразумевается получение новой таблицы путём вырезания строк, 
не удовлетворяющих поставленному условию. 
Маской называется Series, которая состоит из булевых значений, при этом значения 
True соответствуют тем индексам, для которых заданное условие выполняется, в противном случае ставится значение 
False (например, цена > 2 млн).
mask = melb_data['Price'] > 2000000     #Задание маски
melb_data[mask]                         #Применение маски
или
melb_data[melb_data['Price'] > 2000000] #Можно задать условие сразу
Можно объединять условия, но нельзя использовать 'and' и 'or', а нужно '&' и '|' - поэлементную логику.
melb_data[((melb_data['Rooms'] == 3) | (melb_data['BuildingArea'] > 100)) & (melb_data['Price'] < 300000)].shape[0]
Можно объединять условия и методы
mean_price = melb_data['Price'].mean()
melb_data[melb_data['Price'] > mean_price]['BuildingArea'].median()
Можно улучшать читаемость с помощью переменных
mask1 = (melb_data['Rooms'] == 3)
mask2 = (melb_data['BuildingArea'] > 100)
mask3 = (melb_data['Price'] < 300000)
melb_data[(mask1 | mask2) & mask3].shape[0]


popular_stypes =street_types.value_counts().nlargest(10).index
    #nlargest(n) - возвращяет n самых популярных элементов
print(popular_stypes)
# Index(['St', 'Rd', 'Ct', 'Dr', 'Av', 'Gr', 'Pde', 'Pl', 'Cr', 'Cl'], dtype='object')
melb_df['StreetType'] = street_types.apply(lambda x: x if x in popular_stypes else 'other')
    #Если наш элемент не относится к 10 популярных, то он становиться в категорию "другие" - 'other'
display(melb_df['StreetType'])
.nunique() #Показывает число уникмльных элементов


//Работа с DataFrame
melb_df = melb_data.copy() #Создание копии DataFrame
melb_df = melb_df.drop(['index', 'Сoordinates'], axis=1) #Удаление столбцов
    labels — порядковые номера или имена столбцов, которые подлежат удалению; 
    если их несколько, то передаётся список;
    axis — ось совершения операции, axis=0 — удаляются строки, axis=1 — удаляются столбцы;
    inplace — если параметр выставлен на True, происходит замена изначального DataFrame 
    на новый, при этом метод ничего не возвращает; если на False — возвращается копия DataFrame 
    без значений, подлежащих удалению, при этом первоначальный DataFrame не изменяется; по умолчанию 
    параметр равен False.
total_rooms = melb_df['Rooms'] + melb_df['Bedroom'] + melb_df['Bathroom']
    #Возможно соверать математические операции над данными
melb_df['Date'] = pd.to_datetime(melb_df['Date']) #Преодразование 
    #дат в формат YYYY-MM-DD HH: MM: SS
    #что значит год-месяц-день часы:минуты:секунды
years_sold = melb_df['Date'].dt.year
Акцессор df позволяет выделять:
    date — дата;
    year, month, day — год, месяц, день;
    days — период в днях (350 дней, например);
    time — время;
    seconds - время в секундах; #Только для разницы врмени (deltaTime)
    hour, minute, second — час, минута, секунда;
    dayofweek — номер дня недели, от 0 до 6, где 0 — понедельник, 6 — воскресенье;
    weekday_name — название дня недели;
    dayofyear — порядковый день года;
    quarter — квартал (интервал в три месяца).
delta_days = melb_df['Date'] - pd.to_datetime('2016-01-01')  
    #Разница времени с 1 января 2016 до момента продажи

//Функции в Pandas

/Пример
# На вход данной функции поступает строка с адресом.
def get_street_type(address):
# Создаём список географических пометок exclude_list.
    exclude_list = ['N', 'S', 'W', 'E']
# Метод split() разбивает строку на слова по пробелу.
# В результате получаем список слов в строке и заносим его в переменную address_list.
    address_list = address.split(' ')
# Обрезаем список, оставляя в нём только последний элемент,
# потенциальный подтип улицы, и заносим в переменную street_type.
    street_type = address_list[-1]
# Делаем проверку на то, что полученный подтип является географической пометкой.
# Для этого проверяем его на наличие в списке exclude_list.
    if street_type in exclude_list:
# Если переменная street_type является географической пометкой,
# переопределяем её на второй элемент с конца списка address_list.
        street_type = address_list[-2]
# Возвращаем переменную street_type, в которой хранится подтип улицы.
    return street_type

street_types = melb_df['Address'].apply(get_street_type)
display(street_types)

//Определение числа уникальных категорий
# создаём пустой список
unique_list = []
# пробегаемся по именам столбцов в таблице
for col in melb_df.columns:
    # создаём кортеж (имя столбца, число уникальных значений)
    item = (col, melb_df[col].nunique(),melb_df[col].dtype) 
    # добавляем кортеж в список
    unique_list.append(item) 
# создаём вспомогательную таблицу и сортируем её
unique_counts = pd.DataFrame(
    unique_list,
    columns=['Column_Name', 'Num_Unique', 'Type']
).sort_values(by='Num_Unique',  ignore_index=True)
# выводим её на экран
display(unique_counts)

//Преобразование столбцов к типу данных category .astype('category')
cols_to_exclude = ['Date', 'Rooms', 'Bedroom', 'Bathroom', 'Car'] # список столбцов, которые мы не берём во внимание
max_unique_count = 150 # задаём максимальное число уникальных категорий
for col in melb_df.columns: # цикл по именам столбцов
    if melb_df[col].nunique() < max_unique_count and col not in cols_to_exclude: # проверяем условие
        melb_df[col] = melb_df[col].astype('category') # преобразуем тип столбца
display(melb_df.info())
Разберём код подробнее:
1 Задаём список столбцов, которые мы не берём в рассмотрение (cols_to_exclude), а также условленный 
нами ранее порог уникальных значений столбца max_unique_count.
2 В цикле перебираем имена столбцов, и, если число уникальных категорий меньше 
заданного порога и имён столбцов нет в списке cols_to_exclude, то с помощью метода astype() 
приводим столбец к типу данных category.
3 Итоговый объём памяти — 1.9 Мб. В результате такого преобразования объём памяти, 
занимаемый таблицей, уменьшился почти в 1.5 раза. Это впечатляет!

//Атрибуты category .cat.atribyt()
#Получение списка уникальных категорий
print(melb_df['Regionname'].cat.categories)

#Посмотрим, каким образом столбец кодируется в виде чисел в памяти компьютера
print(melb_df['Regionname'].cat.codes)

#Переименование категорий с помощью словаря
melb_df['Type'] = melb_df['Type'].cat.rename_categories({
    'старое название':'новое название',
    'u': 'unit',
    't': 'townhouse',
    'h': 'house'
})

#Добавить категорию
melb_df['Type'] = melb_df['Type'].cat.add_categories('flat')



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////






5.2
/////////////////
///ДЕКОРАТОРЫ///
///////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////






5.2
/////////////////
///ДЕКОРАТОРЫ///
///////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////






5.2
/////////////////
///ДЕКОРАТОРЫ///
///////////////






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































