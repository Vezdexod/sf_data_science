https://vk.com/dev/methods


access_token=vk1.a.f4Cf-9IZro_XjSIoB1XGXpLZf5CIzVkM_RwKosxK7L58nsemL5k60y4X0-4SGzMNRTIZTt8LHalI3NRpDiGuxJI7COlO67JtyQnernUf21yg3mXgUy-4yHIbe1OGNG2KDuqA1Pyga2ys-al4VDQ2_5hbi2IjNzBnA7PKo9RKYwpXo4BpmuAujZi4BnMmygZM0LGw5i-6Gj1Iu2qBkGUruw
&expires_in=0
&user_id=776616366



//API

/КЛЮЧ АВТОРИЗАЦИИ
сервисный ключ авторизации — токен
vk.com SF_Vezdexod
c09ca0c7c09ca0c7c09ca0c776c0e6d236cc09cc09ca0c7a129001f2c1071015ac70010

/ПЕРВЫЕ ЗАПРОСЫ К API
https://api.vk.com/method/users.get?user_id=1&v=5.95&access_token=c09ca0c7c09ca0c7c09ca0c776c0e6d236cc09cc09ca0c7a129001f2c1071015ac70010
{"response":[{"first_name":"Павел","id":1,"last_name":"Дуров","can_access_closed":true,"is_closed":false}]}


Итак, мы сделали GET-запрос к API ВКонтакте, который состоит из следующих элементов:

https://api.vk.com/method — домен и URL запроса API; обычно не меняется;
users.get — название метода, который отдаёт определённый отчёт, в нашем случае это метод для получения информации о пользователе;
user_id и v — параметры запроса: идентификатор пользователя, о котором хотим получить информацию (в нашем примере мы запрашиваем информацию о первом пользователе), и номер версии API;
token — токен, который выдаётся только пользователям, имеющим право просматривать определённые данные, например показания счётчиков Яндекс.Метрики вашего проекта; на все остальные запросы без корректного токена система отвечает отказом.

/ЗАПРОС К API ИЗ КОДА
import requests # Импортируем модуль requests
token = ' ... ' # Указываем свой сервисный токен
url = 'https://api.vk.com/method/users.get' # Указываем адрес страницы к которой делаем запрос
params = {'user_id': 1, 'v': 5.95, 'fields': 'sex,bdate', 'access_token': token, 'lang': 'ru'} # Перечисляем параметры нашего запроса в словаре params
response = requests.get(url, params=params) # Отправляем запрос
print(response.text) # Выводим текст ответа на экран

/СБОР ИНФОРМАЦИИ ИЗ ГРУПП
Согласно документации, обязательным параметром данного метода является group_id — идентификатор, или короткое имя, группы. В нашем случае это vk: https://vk.com/vk. Протестируем, как работает метод в самом простом случае, — получим id участников группы:

import requests # Импортируем модуль requests
token = ' ... ' # Указываем свой сервисный токен
url = 'https://api.vk.com/method/groups.getMembers' # Указываем адрес обращения
params = {'group_id': 'vk', 'v': 5.95, 'access_token': token} # Формируем строку параметров
response = requests.get(url, params = params) # Посылаем запрос
data = response.json() # Ответ сохраняем в переменной data в формате словаря
print(data) # Выводим содержимое переменной data на экран (отображён фрагмент)

По ключу count мы можем получить общее число участников группы, а список по ключу items хранит их id. Посмотрим на него поближе:

print(len(data['response']['items'])) # Выводим на экран количество элементов словаря
#1000

Мы видим, что всего пользователей в группе больше 11 миллионов, а получили мы только первую тысячу пользователей группы. По информации, указанной в документации о параметре count, это максимум, который может отдать API за один раз.

Для получения следующей тысячи пользователей можно воспользоваться параметром offset (с англ. смещение), который передвинет начало отсчёта. Для выгрузки всех пользователей группы будем в цикле выгружать по 1000 пользователей (count будет всегда равен 1000), увеличивая смещение offset на величину count.

Для тренировки напишем цикл выгрузки первых 20 пользователей со значением count=5. Иными словами, мы будем выгружать по пять пользователей за запрос до тех пор, пока не получим информацию о 20 пользователях.

Давайте выведем на экран первые 20 пользователей из нашей первой попытки получить информацию о 1000 пользователей, чтобы мы могли сверить результат выгрузки из 20 пользователей:

users_for_checking = data['response']['items'][:20] # Загружаем в переменную информацию об id первых 20 пользователей в виде списка
print(users_for_checking) # Выводим перечень id первых 20 пользователей

Теперь используем count и offset, чтобы получить те же id по пять за раз:

import requests # Импортируем модуль requests
token = ' ... ' # Указываем свой сервисный токен
url = 'https://api.vk.com/method/groups.getMembers' # Указываем адрес обращения
count = 5 
offset = 0 
user_ids = [] 
max_count = 20 
while offset < max_count: 
    # Будем выгружать по count=5 пользователей, 
    # начиная с того места, где закончили на предыдущей итерации (offset) 
    print('Выгружаю {} пользователей с offset = {}'.format(count, offset))   
    params = {'group_id': 'vk', 'v': 5.95, 'count': count, 'offset': offset, 'access_token': token} 
    response = requests.get(url, params = params) 
    data = response.json() 
    user_ids += data['response']['items'] 
    # Увеличиваем смещение на количество строк, которое мы уже выгрузили 
    offset += count 
print(user_ids) 
#Выгружаю 5 пользователей с offset = 0
#Выгружаю 5 пользователей с offset = 5
#Выгружаю 5 пользователей с offset = 10
#Выгружаю 5 пользователей с offset = 15
#[5, 6, 19, 34, 47, 54, 79, 177, 193, 198, 212, 219, 239, 243, 254, 345, 404, 406, 407, 467]

/ОГРАНИЧЕНИЕ ПО ЧАСТОТЕ ЗАПРОСОВ

→ В API часто добавляют ограничение по частоте запросов, чтобы отдельно взятые пользователи слишком сильно не перегружали сервер. 
Подобное ограничение есть и у ВКонтакте — в документации указано, что можно делать не более трёх запросов в секунду.

Воспользуемся библиотекой time и методом sleep, с помощью которого мы можем добавить паузу, например в 0.5 секунд, после каждого запроса:

import requests # Импортируем модуль requests
import time # Импортируем модуль time
token = ' ... ' # Указываем свой сервисный токен
url = 'https://api.vk.com/method/groups.getMembers' # Указываем адрес страницы, к которой делаем запрос
count = 1000 
offset = 0  
user_ids = []  
while offset < 5000: 
    params = {'group_id': 'vk', 'v': 5.95, 'count': count, 'offset': offset, 'access_token': token} 
    response = requests.get(url, params = params) 
    data = response.json() 
    user_ids += data['response']['items'] 
    offset += count 
    print('Ожидаю 0.5 секунды...') 
    time.sleep(0.5) 
print('Цикл завершен, offset =',offset) 

/ЛАЙКИ, РЕПОСТЫ И КОММЕНТАРИИ

Для получения информации о сообщениях на стене в API ВКонтакте предусмотрен метод wall.get. Применим его:

import requests # Импортируем модуль requests
from pprint import pprint # Импортируем функцию pprint()
token = ' ... ' # Указываем свой сервисный токен
url = 'https://api.vk.com/method/wall.get' # Указываем адрес страницы, к которой делаем запрос
params = {'domain': 'vk', 'filter': 'owner', 'count': 1000, 'offset': 0, 'access_token': token, 'v': 5.95} 
response = requests.get(url, params = params) 
pprint(response.json()) 

Посмотрим на информацию об отдельном сообщении:
response.json()['response']['items'][0] 

Давайте соберём итоговую статистику для последних десяти непустых сообщений в словарь stats. В качестве ключа будем использовать начало сообщения (если начало сообщения пустое, то информацию о таком сообщении проигнорируем), в качестве значения — список с тремя интересующими нас метриками и временем публикации (комментарии, лайки, репосты, дата публикации):

stats = {} 
count_post = 0 # Счётчик «непустых» сообщений
for record in response.json()['response']['items'][:]:
    title = record['text'][:30] 
    if title: 
        stats[title] = [record['comments']['count'], record['likes']['count'], record['reposts']['count'], record['date']] 
        count_post += 1 
    if count_post < 10: 
        continue 
    else: 
        break 
pprint(stats)


//Как настроить регулярную выгрузку данных
/СКРИПТЫ
Как уже говорилось, скриптом принято называть небольшую компьютерную программу, которая автоматизирует выполнение некоторой задачи. 
Программы, которые мы создаём на языке Python, также являются скриптами.

В этом случае вам нужен автоматический запуск скриптов, или, как часто его называют программисты, запуск по крону — от английского 
акронима Cron (англ. Command Run ON) — названия системы для автоматического запуска программ и скриптов на сервере в определённое время.

/КАК НАСТРОИТЬ АВТОМАТИЧЕСКИЙ ЗАПУСК
Исполняемый по расписанию код часто называют задачей (англ. task). 
Для планирования задач в Python есть несколько библиотек, среди которых — популярный и простой в использовании модуль schedule (c англ. расписание). 
Он позволяет запускать код как с определённым интервалом, так и в заданное время.

pip install schedule 

import schedule # Импортируем модуль schedule

def task(): 
    print('Hello! I am a task!') 
    return 

schedule.every(15).minutes.do(task)

Если бы мы хотели запускать задачу, например, каждый час, то могли бы написать:
schedule.every(1).hour.do(task) 

Для создания паузы мы будем использовать метод sleep из модуля time, поэтому наш код начнётся с импорта данного модуля:

import time 
while True: 
    schedule.run_pending() 
    time.sleep(1) 